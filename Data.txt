To handle all types of hierarchies and ensure the script is flexible enough to handle complex XML structures dynamically, I’ll provide a comprehensive Python script along with detailed instructions and examples.

### Comprehensive Python Script

This script reads data from an Excel sheet and creates XML files considering various hierarchies and nested structures.

```python
import pandas as pd
from xml.etree.ElementTree import Element, SubElement, tostring, ElementTree

# Load data from XLSX
df = pd.read_excel('portfolio_data.xlsx')

# Function to determine value type
def determine_value_type(value):
    if isinstance(value, bool):
        return 'boolean'
    elif isinstance(value, int):
        return 'integer'
    elif isinstance(value, float):
        return 'float'
    else:
        return 'string'

# Function to create XML element from DataFrame row
def create_xml_element(row):
    object_element = Element('object')
    object_element.set('type', row.get('Type', 'UnknownType'))
    object_element.set('version', str(row.get('Version', '1.0')))
    object_element.set('stamp', str(row.get('Stamp', 'UnknownStamp')))
    object_element.set('objectId', str(row.get('Object ID', 'UnknownID')))

    for col in df.columns:
        if col not in ['Type', 'Version', 'Stamp', 'Object ID', 'Parent ID', 'Nested Elements']:
            if pd.notna(row[col]):
                property_element = SubElement(object_element, 'property')
                property_element.set('name', col)
                property_element.set('value', str(row[col]))
                property_element.set('valueType', determine_value_type(row[col]))

    # Handle nested elements
    if pd.notna(row.get('Nested Elements')):
        nested_elements = str(row['Nested Elements']).split(';')
        for nested_element in nested_elements:
            nested_parts = nested_element.strip().split('|')
            if len(nested_parts) == 3:
                nested_obj = SubElement(object_element, 'object')
                nested_obj.set('type', nested_parts[0])
                nested_property = SubElement(nested_obj, 'property')
                nested_property.set('name', nested_parts[1])
                nested_property.set('value', nested_parts[2])
                nested_property.set('valueType', 'string')

    return object_element

# Function to build hierarchy from DataFrame
def build_hierarchy(df):
    hierarchy = {}
    for index, row in df.iterrows():
        parent_id = row['Parent ID']
        if parent_id not in hierarchy:
            hierarchy[parent_id] = []
        hierarchy[parent_id].append(row)
    return hierarchy

# Function to recursively add children to parent element
def add_children(parent, hierarchy, parent_id):
    if parent_id in hierarchy:
        for row in hierarchy[parent_id]:
            child_element = create_xml_element(row)
            parent.append(child_element)
            add_children(child_element, hierarchy, row['Object ID'])

# Main function to generate XML
def generate_xml(df):
    hierarchy = build_hierarchy(df)
    root_elements = []
    add_children(root_elements, hierarchy, 'root')

    with open('output.xml', 'wb') as file:
        for element in root_elements:
            file.write(tostring(element, encoding='utf-8'))
            file.write(b'\n')  # Add a newline for readability

    print("XML file created successfully!")

# Run the XML generation
generate_xml(df)
```

### How to Prepare Your Excel File

The Excel file (`portfolio_data.xlsx`) should be structured to capture different hierarchical and nested structures. Here’s an example layout:

#### Example 1: Simple Hierarchical Structure

| Stamp | Object ID | Type | Version | Parent ID | Name | Description | Nested Elements |
|-------|-----------|------|---------|-----------|------|-------------|----------------|
| eee2c2b4 | obj1 | Portfolio | 5.0 | root | AD | Analysis of deposits | ModelBasedObject|modelEntry|dataModel; DataModel|Portfolio[BT].ModifyModel[position].reportDataDictionary |
| eee2c2b5 | obj2 | Portfolio:level | 1.0 | obj1 | Level 1 | Counterparty Industry | |
| eee2c2b6 | obj3 | Portfolio:level | 1.0 | obj1 | Level 2 | Counterparty Sub-type | |
| eee2c2b7 | obj4 | Portfolio:additionalField | 2.0 | obj2 | Line Item | Line item description | |

#### Example 2: Complex Nested Structure

| Stamp | Object ID | Type | Version | Parent ID | Name | Description | Nested Elements |
|-------|-----------|------|---------|-----------|------|-------------|----------------|
| eee2c2b8 | obj5 | Condition:list | 1.0 | root | List | List description | Portfolio|AdditionalInfo|Details; Condition|Summary|SummaryDetails |
| eee2c2b9 | obj6 | Portfolio:localAdditionalFieldReference | 1.0 | obj5 | Field Ref | Field reference description | Portfolio|FieldDetails|MoreDetails |
| eee2c2ba | obj7 | Portfolio:index | 1.0 | obj6 | Index | Index details | |
| eee2c2bb | obj8 | Portfolio:distributionStyle | 1.0 | obj6 | Dist Style | Distribution details | |

#### Example 3: Deeply Nested Hierarchy

| Stamp | Object ID | Type | Version | Parent ID | Name | Description | Nested Elements |
|-------|-----------|------|---------|-----------|------|-------------|----------------|
| eee2c2bc | obj9 | DataModelCondition | 1.0 | root | Condition | Condition details | Condition|SubCondition|SubConditionDetails; DataModel|Reference|DataModelDetails |
| eee2c2bd | obj10 | Portfolio:resultAlias | 1.0 | obj9 | Alias | Alias details | Portfolio|ResultInfo|AliasInfo |
| eee2c2be | obj11 | Portfolio:level | 1.0 | obj10 | Level 3 | Level details | |

### Running the Script

1. **Install Required Packages**:
   Make sure you have `pandas` installed:
   ```bash
   pip install pandas
   ```

2. **Prepare the Excel File**:
   Save your Excel data as `portfolio_data.xlsx` in the same directory as your script.

3. **Run the Script**:
   Execute the script in your Python environment. It will generate an `output.xml` file that reflects the hierarchies and nested structures defined in your Excel file.

### Key Features

- **Flexible Hierarchy Handling**: The script can handle various types of nested and hierarchical structures dynamically, based on the data provided in the Excel sheet.
- **Comprehensive Structure**: It reads all relevant columns and processes them into a hierarchical XML structure.
- **Reusable and Adaptable**: The script is designed to be easily modified for different structures and data formats without extensive changes.

By following these steps and using the provided script, you will be able to generate XML files that accurately reflect complex hierarchical data structures. Feel free to customize the script further if you have more specific requirements or different data formats!
