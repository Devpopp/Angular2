To create a dynamic script that can handle various hierarchical structures as seen in your examples, you need a flexible approach that can process nested elements and dynamic attributes effectively. The script should be able to read from an Excel file and generate XML that matches the complex nested structures without requiring a fixed set of rules for each type of hierarchy.

### Python Script for Dynamic XML Generation

The following script is designed to handle various hierarchical levels dynamically. It reads the structure from the Excel file and creates XML accordingly:

```python
import pandas as pd
from xml.etree.ElementTree import Element, SubElement, tostring, ElementTree
import re

# Load data from XLSX
df = pd.read_excel('portfolio_data.xlsx')

# Function to determine value type
def determine_value_type(value):
    if isinstance(value, bool):
        return 'boolean'
    elif isinstance(value, int):
        return 'integer'
    elif isinstance(value, float):
        return 'float'
    else:
        return 'string'

# Function to create XML element from DataFrame row
def create_xml_element(row):
    # Clean column names to be used as attributes
    row = {col.strip(): row[col] for col in row.index}
    
    # Initialize element
    object_element = Element('object')
    for col in ['Type', 'Version', 'Stamp', 'Object ID']:
        if pd.notna(row.get(col)):
            object_element.set(col.lower().replace(' ', ''), str(row[col]))
    
    # Add properties
    for col in df.columns:
        if col not in ['Type', 'Version', 'Stamp', 'Object ID', 'Parent ID', 'Nested Elements']:
            if pd.notna(row[col]):
                property_element = SubElement(object_element, 'property')
                property_element.set('name', col)
                property_element.set('value', str(row[col]))
                property_element.set('valueType', determine_value_type(row[col]))

    # Add nested elements
    if pd.notna(row.get('Nested Elements')):
        nested_elements = str(row['Nested Elements']).split(';')
        for nested_element in nested_elements:
            nested_parts = nested_element.strip().split('|')
            if len(nested_parts) == 3:
                nested_obj = SubElement(object_element, 'object')
                nested_obj.set('type', nested_parts[0])
                nested_property = SubElement(nested_obj, 'property')
                nested_property.set('name', nested_parts[1])
                nested_property.set('value', nested_parts[2])
                nested_property.set('valueType', 'string')

    return object_element

# Function to build hierarchy from DataFrame
def build_hierarchy(df):
    hierarchy = {}
    for index, row in df.iterrows():
        parent_id = row['Parent ID']
        if parent_id not in hierarchy:
            hierarchy[parent_id] = []
        hierarchy[parent_id].append(row)
    return hierarchy

# Function to recursively add children to parent element
def add_children(parent, hierarchy, parent_id):
    if parent_id in hierarchy:
        for row in hierarchy[parent_id]:
            child_element = create_xml_element(row)
            parent.append(child_element)
            add_children(child_element, hierarchy, row['Object ID'])

# Main script logic
def generate_xml(df):
    hierarchy = build_hierarchy(df)
    root_elements = []
    add_children(root_elements, hierarchy, 'root')

    with open('output.xml', 'wb') as file:
        for element in root_elements:
            file.write(tostring(element, encoding='utf-8'))

    print("XML file created successfully!")

# Run the XML generation
generate_xml(df)
```

### Key Features of the Script

1. **Dynamic Handling of Columns**:
   - The script reads all columns dynamically and sets them as attributes or nested properties based on the data in each row.

2. **Recursive Structure Building**:
   - It uses a recursive function `add_children` to handle nested hierarchies dynamically, allowing for flexible XML generation based on the input data.

3. **Flexible Nested Elements**:
   - The `Nested Elements` column is used to specify nested objects, allowing complex hierarchies to be captured in a simple format in the Excel sheet.

4. **Generic and Reusable**:
   - This script can handle any hierarchical structure as long as it is properly defined in the Excel file, making it highly reusable for different types of data.

### How to Structure Your Excel File

Your Excel file should follow a structure that can include all relevant data for the XML generation:

| Stamp | Object ID | Type | Version | Parent ID | Name | Description | Include New Models in Execution | Non-Key Variables | Detail Set | Storage Type | Additional Indices | Clustered | Unique | Fields | Distribution Style | Portfolio Result Alias | Four Eyes Check | Validations | Producing Is Root | Sequence | Ignore Errors in Aggregated Condition Placement | Make As Of Date Column Nullable | Compute Statistics | Allow Multiple Nodes per Record | Execution Algorithm | Levels | Level ID | Level Name | Default Value | Allow Nulls | Allow Nulls Fixed | Size | Lookup Source | Condition Type | Condition Tree | Grouping Operator | Instance Key Rules | Instance Selection Rule | Actions | Models | Nested Elements |
|-------|-----------|------|---------|-----------|------|-------------|---------------------------------|-------------------|------------|--------------|--------------------|-----------|--------|--------|-------------------|-----------------------|----------------|-------------|----------------|---------|---------------------------------------------|---------------------------|-----------------|-------------------------|-------------------|-------|---------|------------|--------------|-----------|----------------|------|--------------|---------------|---------------|----------------|----------------|--------------------|-------|-------|----------------|
| eee2c2b4 | obj1 | Portfolio | 5.0 | root | AD | Analysis of deposits | True | var1, var2 | dataset1 | SEGMENTED | index1;index2 | False | True | field1;field2 | INHERIT | alias1 | True | validation1 | False | seq1 | True | True | FOR_ALL_COLUMNS | True | long_queries | Level1, Level2 | level1 | Section | default1 | True | False | 10 | lookup1 | type1 | tree1 | AND | rule1 | rule2 | action1 | model1 | Portfolio|dataModel|Portfolio[BT].ModifyModel[position].reportDataDictionary |

- **`Parent ID`**: Indicates the parent of the current row's object. Use 'root' for top-level objects.
- **`Nested Elements`**: Specifies nested elements in the format `type|name|value`, separated by semicolons for multiple nested elements.

By following this approach, you can dynamically generate XML files from a variety of hierarchical data structures specified in your Excel file, without needing to hardcode specific details for each hierarchy.
