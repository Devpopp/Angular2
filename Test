import { Component, OnInit } from '@angular/core';
import { ColDef, GridApi, GridReadyEvent } from 'ag-grid-community';
import { DataService } from './data.service'; // Replace with your actual data service path

@Component({
  selector: 'app-my-dynamic-table',
  template: `
    <ag-grid-angular
      style="width: 100%; height: 500px;" // You can adjust the height as needed
      class="ag-theme-alpine"
      [rowData]="rowData"
      [columnDefs]="columnDefs"
      [defaultColDef]="defaultColDef"
      [animateRows]="true"
      [pagination]="true"
      [paginationPageSize]="10"
      (gridReady)="onGridReady($event)">
    </ag-grid-angular>
  `
})
export class MyDynamicTableComponent implements OnInit {
  private gridApi!: GridApi;
  public columnDefs: ColDef[] = [];
  public defaultColDef: ColDef = {
    filter: 'agTextColumnFilter',
    floatingFilter: true,
    sortable: true,
    resizable: true,
    autoHeight: true,
    minWidth: 100
  };
  public rowData: any[] = [];

  constructor(private dataService: DataService) {}

  ngOnInit(): void {
    this.dataService.getCurrentData().subscribe(data => {
      this.rowData = JSON.parse(data.currentmonthmaindata_json);
      this.columnDefs = this.generateColumnDefinitions(this.rowData);
    });
  }

  generateColumnDefinitions(data: any[]): ColDef[] {
    if (data.length === 0) {
      return [];
    }
    return Object.keys(data[0]).map(key => ({
      field: key,
      headerName: this.capitalizeFirstLetter(key.replace(/_/g, ' ')),
      filter: true,
      sortable: true,
      resizable: true
    }));
  }

  onGridReady(params: GridReadyEvent) {
    this.gridApi = params.api;
    this.gridApi.sizeColumnsToFit();
  }

  private capitalizeFirstLetter(string: string): string {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
}






suming merged_data is your DataFrame after merging leadbase data and master_data
# and that app_name and app_count have been calculated with the desired methods.

# Get the details for each application product name without aggregation
app_details = merged_data[['Global_Lead_First_Name', 'Application_Product_Name', 'CI_Count', 
                           'Incident_Count', 'Total_Cost', 'Storage_Cost', 'Database_Cost']]

# You might want to drop duplicates if there are any
app_details = app_details.drop_duplicates(subset=['Global_Lead_First_Name', 'Application_Product_Name'])

# Merge the application counts and names with the detailed DataFrame
app_counts = leadbasedata.groupby('Global_Lead_First_Name')['Application_Product_Name'].nunique().reset_index(name='App_Count')
app_names = leadbasedata.groupby('Global_Lead_First_Name')['Application_Product_Name'].apply(lambda x: x.unique().tolist()).reset_index(name='App_Names')

# Merge the counts and names into the details
final_details = app_details.merge(app_counts, on='Global_Lead_First_Name', how='left')
final_details = final_details.merge(app_names, on='Global_Lead_First_Name', how='left')

# Now final_details DataFrame has the structure:
# | Global_Lead_First_Name | Application_Product_Name | CI_Count | Incident_Count | Total_Cost | Storage_Cost | Database_Cost | App_Count | App_Names |

# Convert the detailed DataFrame to JSON if needed
final_details_json = final_details.to_json(orient='records')

# Print or return the final details
print("final_details", final_details_json)
